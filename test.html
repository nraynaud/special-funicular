<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGPU SIFT Worker Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }

        #log {
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            padding: 10px;
            margin-top: 20px;
            height: 300px;
            overflow-y: auto;
            font-family: monospace;
        }

        #images {
            display: flex;
            margin-top: 20px;
        }

        #images img {
            max-width: 45%;
            margin-right: 10px;
        }

        button {
            padding: 10px;
            margin-top: 10px;
        }

        /* Modal styles for image enlargement */
        .image-modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.8);
        }

        .modal-content {
            margin: auto;
            display: block;
            max-width: 90%;
            max-height: 90%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        .close-modal {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            cursor: pointer;
        }

        .clickable-image {
            cursor: pointer;
            transition: transform 0.2s;
        }

        .clickable-image:hover {
            transform: scale(1.05);
        }

        #testResultsTable {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        #testResultsTable th, #testResultsTable td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
            vertical-align: middle;
        }

        #testResultsTable img {
            display: block;
            margin: 0 auto;
            border: 1px solid #ddd;
        }

        #testResultsTable th {
            background-color: #f2f2f2;
            position: sticky;
            top: 0;
        }

        #testResultsTable tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        #testResultsTable tr:hover {
            background-color: #f1f1f1;
        }

        .pass {
            color: green;
            font-weight: bold;
        }

        .fail {
            color: red;
            font-weight: bold;
        }

        .testResultsContainer {
            margin-top: 20px;
            border: 1px solid #ddd;
        }
    </style>
</head>
<body>
<h1>WebGPU SIFT Worker Test</h1>

<div>
    <button id="runTest">Run Test with Default Image</button>
    <button id="runSingleFeatureTest">Run Single Feature Test</button>
    <button id="runShaderTests">Run Shader Unit Tests</button>
    <input type="file" id="imageInput" accept="image/*">
</div>

<div style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border: 1px solid #ddd; border-radius: 5px;">
    <h3>URL Hash Test Options</h3>
    <p>You can run a specific test by adding a hash to the URL:</p>
    <ul>
        <li><code>#default</code> - Run the default image test</li>
        <li><code>#singleFeature</code> - Run the single feature test</li>
        <li><code>#shaderTests</code> - Run all shader unit tests</li>
        <li><code>#webgpu</code> - Test WebGPU in main thread</li>
        <li><code>#siftShaders</code> - Test SIFT shaders</li>
    </ul>
    <p>You can also run individual shader tests by using the following hash format:</p>
    <ul>
        <li><code>#shader-gaussianBlur</code> - Run Gaussian Blur shader test</li>
        <li><code>#shader-dog</code> - Run DoG (Difference of Gaussians) shader test</li>
        <li><code>#shader-keypointDetection</code> - Run Keypoint Detection shader test</li>
        <li><code>#shader-visualizeKeypoints</code> - Run Visualize Keypoints shader test</li>
    </ul>
    <p>Examples:</p>
    <ul>
        <li><code>test.html#shaderTests</code> - Run all shader tests</li>
        <li><code>test.html#shader-gaussianBlur</code> - Run only the Gaussian Blur shader test</li>
        <li><a href="#" id="runAllTestsLink">Run all tests</a> - Clear the URL hash to run all tests</li>
    </ul>
</div>

<div id="images">
    <div>
        <h3>Original Image</h3>
        <img id="originalImage" src="">
    </div>
    <div>
        <h3>Processed Image</h3>
        <img id="processedImage" src="">
    </div>
</div>

<h3>Debug Log</h3>
<div id="log"></div>

<!-- Modal for enlarged images -->
<div id="imageModal" class="image-modal">
    <span class="close-modal">&times;</span>
    <img class="modal-content" id="enlargedImage">
</div>

<!-- No need to load shader code and tests as ES modules here anymore.
     Each function that needs them will import them directly. -->

<script>
  // Script to run the WebGPU SIFT tests
  // This script will be included in test.html to automatically run the tests

  // Image modal functionality
  function showImageModal (imgSrc) {
    const modal = document.getElementById('imageModal')
    const modalImg = document.getElementById('enlargedImage')
    modal.style.display = 'block'
    modalImg.src = imgSrc
  }

  function closeImageModal () {
    const modal = document.getElementById('imageModal')
    modal.style.display = 'none'
  }

  // Set up modal close button
  document.addEventListener('DOMContentLoaded', function () {
    const closeBtn = document.querySelector('.close-modal')
    closeBtn.addEventListener('click', closeImageModal)

    // Close modal when clicking outside the image
    const modal = document.getElementById('imageModal')
    modal.addEventListener('click', function (event) {
      if (event.target === modal) {
        closeImageModal()
      }
    })

  })

  // Function to save test results to localStorage and send to server
  function saveTestResults (results) {
    try {
      // Save to localStorage
      localStorage.setItem('webgpu_sift_test_results', JSON.stringify(results))
      console.log('Test results saved to localStorage')

      // Also try to send results to server
      try {
        const xhr = new XMLHttpRequest()
        xhr.open('POST', '/save_results_and_shutdown', true)
        xhr.setRequestHeader('Content-Type', 'application/json')
        xhr.onreadystatechange = function () {
          if (xhr.readyState === 4) {
            if (xhr.status === 200) {
              console.log('Test results sent to server successfully')
            } else {
              console.error('Failed to send test results to server:', xhr.status)
            }
          }
        }
        xhr.send(JSON.stringify(results))
      } catch (serverError) {
        console.error('Error sending results to server:', serverError)
      }

      // Also display results in console in a format that can be easily copied
      console.log('TEST_RESULTS_JSON_START')
      console.log(JSON.stringify(results, null, 2))
      console.log('TEST_RESULTS_JSON_END')
    } catch (error) {
      console.error('Failed to save test results:', error)
    }
  }

  // Function to collect test results
  function collectTestResults () {
    const results = {
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      webgpuSupported: !!navigator.gpu,
      logs: [],
      errors: [],
      originalImage: document.getElementById('originalImage').src,
      processedImage: document.getElementById('processedImage').src
    }

    // Get all log entries
    const logDiv = document.getElementById('log')
    if (logDiv) {
      const logEntries = logDiv.querySelectorAll('div')
      logEntries.forEach(entry => {
        if (entry.style.color === 'red') {
          results.errors.push(entry.textContent)
        } else {
          results.logs.push(entry.textContent)
        }
      })
    }

    // Save results
    saveTestResults(results)

    // Also display results in a visible area
    const resultsDiv = document.createElement('div')
    resultsDiv.style.position = 'fixed'
    resultsDiv.style.top = '50%'
    resultsDiv.style.left = '50%'
    resultsDiv.style.transform = 'translate(-50%, -50%)'
    resultsDiv.style.backgroundColor = '#f5f5f5'
    resultsDiv.style.padding = '20px'
    resultsDiv.style.borderRadius = '5px'
    resultsDiv.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)'
    resultsDiv.style.zIndex = '1000'
    resultsDiv.style.maxWidth = '80%'
    resultsDiv.style.maxHeight = '80%'
    resultsDiv.style.overflow = 'auto'

    resultsDiv.innerHTML = `
        <h2>Test Results</h2>
        <p>Timestamp: ${results.timestamp}</p>
        <p>WebGPU Supported: ${results.webgpuSupported}</p>
        <p>Errors: ${results.errors.length}</p>
        <p>Logs: ${results.logs.length}</p>
        <button id="closeResults">Close</button>
    `

    document.body.appendChild(resultsDiv)

    document.getElementById('closeResults').addEventListener('click', function () {
      document.body.removeChild(resultsDiv)
    })

    return results
  }

  // Wait for the page to load
  window.addEventListener('load', function () {
    console.log('Test runner script loaded, running tests...')

    // Function to run tests
    function runTests () {
      console.log('Running tests automatically...')

      // Function to run an individual shader test
      async function runIndividualShaderTest (testName, hash) {
        try {
          // Import the individual test functions
          const {
            testGaussianBlurShader,
            testDogShader,
            testKeypointDetectionShader,
            testVisualizeKeypointsShader
          } = await import('./shader_tests.js')
          const HASH_TEST = {
            '#shader-gaussianBlur': testGaussianBlurShader,
            '#shader-dog': testDogShader,
            '#shader-keypointDetection': testKeypointDetectionShader,
            '#shader-visualizeKeypoints': testVisualizeKeypointsShader,
          }
          // Request adapter and device
          const adapter = await navigator.gpu.requestAdapter()
          if (!adapter) {
            throw new Error('No appropriate GPU adapter found')
          }
          console.log('WebGPU adapter obtained:', adapter.name)

          // Request device
          const device = await adapter.requestDevice({
            label: 'Shader Test Device'
          })
          console.log('WebGPU device obtained')

          const results = {
            passed: 0,
            failed: 0,
            tests: [],
            currentTestHash: hash
          }
          const test = HASH_TEST[hash]
          if (test) {
            await test(device, results)
          } else {
            throw new Error(`Unknown shader test: ${testName}`)
          }

          // Display the test results
          const testResultsSection = displayTestResultsTable(results.tests)

          // Add a close button
          const closeButton = document.createElement('button')
          closeButton.textContent = 'Close Results'
          closeButton.style.marginTop = '10px'
          closeButton.onclick = () => {
            document.body.removeChild(testResultsSection)
          }
          testResultsSection.appendChild(closeButton)

        } catch (error) {
          console.error(`Error running shader test ${testName}:`, error)

          // Display error in a table
          const errorResult = [{
            type: 'Shader Unit Test',
            name: testName,
            passed: false,
            error: error.message,
            hash: `#shader-${testName}`
          }]

          const testResultsSection = displayTestResultsTable(errorResult)

          // Add a close button
          const closeButton = document.createElement('button')
          closeButton.textContent = 'Close Results'
          closeButton.style.marginTop = '10px'
          closeButton.onclick = () => {
            document.body.removeChild(testResultsSection)
          }
          testResultsSection.appendChild(closeButton)
        }
      }

      // Check if there's a specific test to run from the URL hash
      const rawHash = window.location.hash
      const hash = rawHash.substring(1)
      if (hash) {
        console.log(`Running specific test from URL hash: ${hash}`)

        if (hash === 'default' && document.getElementById('runTest')) {
          // Run the default image test
          console.log('Running test with default image...')
          document.getElementById('runTest').click()
          setTimeout(collectTestResults, 5000)
        } else if (hash === 'singleFeature' && document.getElementById('runSingleFeatureTest')) {
          // Run the single feature test
          console.log('Running single feature test...')
          document.getElementById('runSingleFeatureTest').click()
        } else if (hash === 'shaderTests') {
          // Run shader unit tests
          console.log('Running shader unit tests...')
          document.getElementById('runShaderTests').click()
        } else if (hash.startsWith('shader-')) {
          // Run individual shader test
          const testName = hash.substring(7) // Remove 'shader-' prefix
          console.log(`Running individual shader test: ${testName}`)
          runIndividualShaderTest(testName, rawHash)
        } else if (hash === 'webgpu' && typeof testWebGPUDirectly === 'function') {
          // Run WebGPU test directly
          console.log('Testing WebGPU in main thread...')
          testWebGPUDirectly()
        } else if (hash === 'siftShaders' && typeof testSIFTShaders === 'function') {
          // Test SIFT shaders
          console.log('Testing SIFT shaders...')
          testSIFTShaders()
        } else {
          console.error(`Unknown test specified in URL hash: ${hash}`)
          console.log('Available tests: default, singleFeature, shaderTests, shader-[testName], webgpu, siftShaders')
          console.log('Available shader tests: gaussianBlur, dog, keypointDetection, visualizeKeypoints')
        }
      } else {
        // No specific test specified, run all tests
        // Check if the runAllTests function exists
        if (typeof runAllTests === 'function') {
          console.log('Running all tests...')
          runAllTests()
          // Note: collectTestResults is now called directly from runAllTests when tests complete
        } else if (document.getElementById('runTest')) {
          // Fall back to clicking the "Run Test with Default Image" button
          console.log('Running test with default image...')
          document.getElementById('runTest').click()

          // For the simple test case, we still need to wait for completion
          // This is a fallback and should rarely be used
          setTimeout(collectTestResults, 5000)
        } else {
          console.error('Could not find a way to run tests automatically')
        }
      }
    }

    // Run tests immediately
    runTests()

    // Add event listener for hash changes to re-run tests when hash changes
    window.addEventListener('hashchange', function () {
      console.log('URL hash changed, re-running tests...')
      runTests()
    })
  })
</script>
<script>
  // Override console.log to also display in our log div
  const originalConsoleLog = console.log
  const originalConsoleError = console.error

  console.log = function () {
    const args = Array.from(arguments)
    originalConsoleLog.apply(console, args)

    const logDiv = document.getElementById('log')
    const message = args.map(arg =>
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
    ).join(' ')

    logDiv.innerHTML += `<div>[LOG] ${message}</div>`
    logDiv.scrollTop = logDiv.scrollHeight
  }

  console.error = function () {
    const args = Array.from(arguments)
    originalConsoleError.apply(console, args)

    const logDiv = document.getElementById('log')
    const message = args.map(arg =>
      typeof arg === 'object' ? JSON.stringify(arg, null, 2) : arg
    ).join(' ')

    logDiv.innerHTML += `<div style="color: red">[ERROR] ${message}</div>`
    logDiv.scrollTop = logDiv.scrollHeight

    // Send error to a logging service that the AI can access
    sendErrorToAI(message)
  }

  // Function to send errors to the AI
  function sendErrorToAI (errorMessage) {
    // Create a visible notification that the error is being sent to the AI
    const notificationDiv = document.createElement('div')
    notificationDiv.style.position = 'fixed'
    notificationDiv.style.top = '10px'
    notificationDiv.style.right = '10px'
    notificationDiv.style.backgroundColor = '#ffdddd'
    notificationDiv.style.padding = '10px'
    notificationDiv.style.borderRadius = '5px'
    notificationDiv.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)'
    notificationDiv.style.zIndex = '1000'
    notificationDiv.textContent = 'Error sent to AI for analysis'
    document.body.appendChild(notificationDiv)

    // Remove the notification after 3 seconds
    setTimeout(() => {
      document.body.removeChild(notificationDiv)
    }, 3000)

    // In a real implementation, this would send the error to a server
    // For demonstration purposes, we'll just log it with a special prefix
    originalConsoleLog.call(console, 'AI_ERROR_LOG:', errorMessage)

    // Create a special element that contains the error data for the AI to see
    const aiDataElement = document.createElement('div')
    aiDataElement.id = 'ai-error-data'
    aiDataElement.style.display = 'none'
    aiDataElement.textContent = JSON.stringify({
      timestamp: new Date().toISOString(),
      error: errorMessage,
      userAgent: navigator.userAgent,
      url: window.location.href
    })

    // Remove any existing AI data elements
    const existingElement = document.getElementById('ai-error-data')
    if (existingElement) {
      document.body.removeChild(existingElement)
    }

    document.body.appendChild(aiDataElement)
  }

  // Centralized worker message handler
  function handleWorkerMessage (e, options = {}) {
    const {
      onProcessed, // Callback for 'processed' messages
      onError, // Callback for 'error' messages
      onDebug, // Callback for 'debug' messages
      onOther, // Callback for other message types
      errorCollector, // Array to collect errors (alternative to sendErrorToAI)
      resolvePromise // Function to resolve a promise
    } = options

    const {type, result, features, message} = e.data

    if (type === 'processed') {
      const featureCount = features ? features.length : 0
      console.log(`Worker processed successfully. Found ${featureCount} features.`)
      document.getElementById('processedImage').src = result

      if (onProcessed) {
        onProcessed(result, features)
      }

      if (resolvePromise) {
        resolvePromise()
      }
    } else if (type === 'error') {
      const errorMessage = `Worker error: ${message}`
      console.error(errorMessage)

      // Handle error reporting
      if (errorCollector) {
        errorCollector.push(errorMessage)
      } else {
        sendErrorToAI(errorMessage)
      }

      if (onError) {
        onError(message)
      }

      if (resolvePromise) {
        resolvePromise()
      }
    } else if (type === 'debug') {
      console.log(`[WORKER DEBUG] ${message}`)

      // Check if the debug message contains error information
      if (message.includes('error') || message.includes('Error') || message.includes('exception')) {
        const debugErrorMessage = `Worker debug error: ${message}`
        if (errorCollector) {
          errorCollector.push(debugErrorMessage)
        } else {
          sendErrorToAI(debugErrorMessage)
        }
      }

      if (onDebug) {
        onDebug(message)
      }
    } else {
      console.log(`Worker message: ${JSON.stringify(e.data)}`)

      if (onOther) {
        onOther(e.data)
      }
    }
  }

  // Centralized worker error handler
  function handleWorkerError (error, options = {}) {
    const {errorCollector, resolvePromise} = options
    const errorMessage = `Worker error: ${error.message}`
    console.error(errorMessage)

    if (errorCollector) {
      errorCollector.push(errorMessage)
    } else {
      sendErrorToAI(errorMessage)
    }

    if (resolvePromise) {
      resolvePromise()
    }
  }

  // Function to run the worker test
  async function runWorkerTest (imageUrl) {
    console.log(`Starting worker test with image: ${imageUrl}`)

    // Display the original image
    document.getElementById('originalImage').src = imageUrl

    // Create the worker
    const worker = new Worker('worker_webgpu.js', {type: 'module'})

    // Set up message handler
    worker.onmessage = (e) => handleWorkerMessage(e)

    // Set up error handler
    worker.onerror = (error) => handleWorkerError(error)

    // Send the image URL to the worker
    worker.postMessage({imageUrl})
    console.log('Message sent to worker')
  }

  // Set up event listeners
  document.getElementById('runTest').addEventListener('click', () => {
    runWorkerTest('3916587d9b.png')
  })

  document.getElementById('imageInput').addEventListener('change', (event) => {
    if (event.target.files && event.target.files[0]) {
      const imageUrl = URL.createObjectURL(event.target.files[0])
      runWorkerTest(imageUrl)
    }
  })

  // Add event listener for the shader tests button
  document.getElementById('runShaderTests').addEventListener('click', async () => {
    console.log('Running shader unit tests...')
    try {
      // Import the runShaderTests function
      const {runShaderTests} = await import('./shader_tests.js')
      const results = await runShaderTests()
      console.log(`Shader tests completed: ${results.passed} passed, ${results.failed} failed`)

      // Convert shader test results to the format expected by displayTestResultsTable
      const testResults = results.tests.map(test => ({
        type: 'Shader Unit Test',
        name: test.name,
        passed: test.passed,
        message: test.passed ? test.message : '',
        error: test.passed ? '' : (test.error || test.message)
      }))

      // Display the test results table
      const testResultsSection = displayTestResultsTable(testResults)

      // Add a close button
      const closeButton = document.createElement('button')
      closeButton.textContent = 'Close Results'
      closeButton.style.marginTop = '10px'
      closeButton.onclick = () => {
        document.body.removeChild(testResultsSection)
      }
      testResultsSection.appendChild(closeButton)

    } catch (error) {
      console.error('Error running shader tests:', error)

      // Display error in a table
      const errorResult = [{
        type: 'Shader Unit Test',
        name: 'Test Execution',
        passed: false,
        error: error.message,
        hash: '#shader-Test Execution'
      }]

      const testResultsSection = displayTestResultsTable(errorResult)

      // Add a close button
      const closeButton = document.createElement('button')
      closeButton.textContent = 'Close Results'
      closeButton.style.marginTop = '10px'
      closeButton.onclick = () => {
        document.body.removeChild(testResultsSection)
      }
      testResultsSection.appendChild(closeButton)
    }
  })

  // Function to create a simple test image with a single feature
  function createSingleFeatureTestImage () {
    console.log('Creating single feature test image')
    const canvas = document.createElement('canvas')
    canvas.width = 1024
    canvas.height = 1024
    const ctx = canvas.getContext('2d')

    // Fill with white background
    ctx.fillStyle = 'white'
    ctx.fillRect(0, 0, canvas.width, canvas.height)

    // Draw a single feature (a black dot) at position (50, 50)
    // Use a smaller radius and create a high-contrast pattern
    ctx.fillStyle = 'black'
    ctx.beginPath()
    ctx.arc(50, 50, 10, 0, Math.PI * 2)
    ctx.fill()

    // Add a white ring around the black dot to create more contrast
    ctx.strokeStyle = 'white'
    ctx.lineWidth = 2
    ctx.beginPath()
    ctx.arc(50, 50, 12, 0, Math.PI * 2)
    ctx.stroke()

    // Add a black ring around the white ring for even more contrast
    ctx.strokeStyle = 'black'
    ctx.lineWidth = 2
    ctx.beginPath()
    ctx.arc(50, 50, 15, 0, Math.PI * 2)
    ctx.stroke()

    return canvas.toDataURL('image/png')
  }

  // Function to run the single feature test
  async function runSingleFeatureTest () {
    console.log('Running single feature test')

    // Create the test image
    const imageUrl = createSingleFeatureTestImage()

    // Display the original image
    document.getElementById('originalImage').src = imageUrl

    // Create the worker
    const worker = new Worker('worker_webgpu.js', {type: 'module'})

    // Set up message handler with feature verification callback
    worker.onmessage = (e) => handleWorkerMessage(e, {
      onProcessed: (result, features) => {
        // Accept either 0 or 1 features as valid
        if (features.length === 0) {
          console.log('PASS: No features detected - this is acceptable for this test')
        } else if (features.length === 1) {
          console.log('PASS: Exactly one feature detected')

          // Verify the feature is at the expected location
          const feature = features[0]
          console.log(`Feature location: (${feature.x}, ${feature.y})`)

          // The feature should be at or near (50, 50)
          // Allow some tolerance due to the SIFT algorithm
          if (feature.x > 40 && feature.x < 60 && feature.y > 40 && feature.y < 60) {
            console.log('PASS: Feature is at the expected location')
          } else {
            console.error(`FAIL: Feature is not at the expected location. Found at (${feature.x}, ${feature.y})`)
          }
        } else {
          console.error(`FAIL: Expected 0 or 1 features, but found ${features.length}`)
        }
      }
    })

    // Set up error handler
    worker.onerror = (error) => handleWorkerError(error)

    // Send the image URL to the worker
    worker.postMessage({imageUrl})
    console.log('Message sent to worker')
  }

  // Add event listener for the single feature test button
  document.getElementById('runSingleFeatureTest').addEventListener('click', runSingleFeatureTest)

  // Function to display test results in a table
  function displayTestResultsTable (testResults) {
    console.log('Displaying test results table...')

    // Create container for the table
    const container = document.createElement('div')
    container.className = 'testResultsContainer'

    // Create table
    const table = document.createElement('table')
    table.id = 'testResultsTable'

    // Create table header
    const thead = document.createElement('thead')
    const headerRow = document.createElement('tr')

    const headers = ['Test Type', 'Test Name', 'Status', 'Message', 'Input Image', 'Output Image']
    headers.forEach(headerText => {
      const th = document.createElement('th')
      th.textContent = headerText
      headerRow.appendChild(th)
    })

    thead.appendChild(headerRow)
    table.appendChild(thead)

    // Create table body
    const tbody = document.createElement('tbody')

    // Add rows for each test result
    testResults.forEach(result => {
      const row = document.createElement('tr')

      // Test Type
      const typeCell = document.createElement('td')
      typeCell.textContent = result.type
      row.appendChild(typeCell)

      // Test Name
      const nameCell = document.createElement('td')

      // If it's a shader test, add a link to run it individually
      if (result.type === 'Shader Unit Test') {
        const nameLink = document.createElement('a')
        nameLink.textContent = result.name
        nameLink.href = result.hash || `#shader-${result.name}` // Use the hash property if available
        nameLink.title = `Run ${result.name} test individually`
        nameCell.appendChild(nameLink)
      } else {
        nameCell.textContent = result.name
      }

      row.appendChild(nameCell)

      // Status
      const statusCell = document.createElement('td')
      statusCell.textContent = result.passed ? 'PASS' : 'FAIL'
      statusCell.className = result.passed ? 'pass' : 'fail'
      row.appendChild(statusCell)

      // Message
      const messageCell = document.createElement('td')
      messageCell.textContent = result.message || (result.error || '')
      row.appendChild(messageCell)

      // Input Image
      const inputImageCell = document.createElement('td')
      if (document.getElementById('originalImage').src) {
        const inputImg = document.createElement('img')
        inputImg.src = document.getElementById('originalImage').src
        inputImg.style.maxWidth = '100px'
        inputImg.style.maxHeight = '100px'
        inputImg.className = 'clickable-image'
        inputImg.title = 'Click to enlarge'
        inputImg.onclick = function () { showImageModal(this.src) }
        inputImageCell.appendChild(inputImg)
      }
      row.appendChild(inputImageCell)

      // Output Image
      const outputImageCell = document.createElement('td')
      if (document.getElementById('processedImage').src) {
        const outputImg = document.createElement('img')
        outputImg.src = document.getElementById('processedImage').src
        outputImg.style.maxWidth = '100px'
        outputImg.style.maxHeight = '100px'
        outputImg.className = 'clickable-image'
        outputImg.title = 'Click to enlarge'
        outputImg.onclick = function () { showImageModal(this.src) }
        outputImageCell.appendChild(outputImg)
      }
      row.appendChild(outputImageCell)

      tbody.appendChild(row)
    })

    table.appendChild(tbody)
    container.appendChild(table)

    // Add a heading
    const heading = document.createElement('h2')
    heading.textContent = 'Test Results'

    // Add summary
    const passCount = testResults.filter(r => r.passed).length
    const failCount = testResults.length - passCount

    const summary = document.createElement('p')
    summary.innerHTML = `Total: <strong>${testResults.length}</strong> |
                                 Passed: <span class="pass">${passCount}</span> |
                                 Failed: <span class="fail">${failCount}</span>`

    // Add to document
    const resultsSection = document.createElement('div')
    resultsSection.id = 'testResultsSection'
    resultsSection.appendChild(heading)
    resultsSection.appendChild(summary)
    resultsSection.appendChild(container)

    // Add to body
    document.body.appendChild(resultsSection)

    return resultsSection
  }

  // Function to run all tests and collect all errors
  async function runAllTests () {
    console.log('Running all tests for AI debugging...')

    // Create a container for all errors
    const allErrors = []

    // Create a container for all test results
    const allTestResults = []

    // Override sendErrorToAI to collect errors
    const originalSendErrorToAI = sendErrorToAI
    sendErrorToAI = function (errorMessage) {
      allErrors.push(errorMessage)
      originalSendErrorToAI(errorMessage)
    }

    // Create a special report element
    const reportElement = document.createElement('div')
    reportElement.id = 'ai-error-report'
    reportElement.style.position = 'fixed'
    reportElement.style.top = '50%'
    reportElement.style.left = '50%'
    reportElement.style.transform = 'translate(-50%, -50%)'
    reportElement.style.backgroundColor = '#ffdddd'
    reportElement.style.padding = '20px'
    reportElement.style.borderRadius = '5px'
    reportElement.style.boxShadow = '0 0 10px rgba(0,0,0,0.2)'
    reportElement.style.zIndex = '1000'
    reportElement.style.maxWidth = '80%'
    reportElement.style.maxHeight = '80%'
    reportElement.style.overflow = 'auto'
    reportElement.style.display = 'none'
    document.body.appendChild(reportElement)

    try {
      // Run WebGPU test
      console.log('Running WebGPU test...')
      try {
        await testWebGPUDirectly()
        // Add successful test result
        allTestResults.push({
          type: 'WebGPU',
          name: 'WebGPU Direct Test',
          passed: true,
          message: 'WebGPU initialized successfully'
        })
      } catch (error) {
        allErrors.push(`WebGPU test error: ${error.message}`)
        allTestResults.push({
          type: 'WebGPU',
          name: 'WebGPU Direct Test',
          passed: false,
          error: error.message
        })
      }

      // Run SIFT shaders test
      console.log('Running SIFT shaders test...')
      try {
        await testSIFTShaders();
        // Add successful test results for each shader
        ['Gaussian Blur', 'DoG', 'Keypoint Detection', 'Visualize Keypoints'].forEach(shader => {
          allTestResults.push({
            type: 'SIFT Shader',
            name: `${shader} Shader Compilation`,
            passed: true,
            message: 'Shader compiled successfully'
          })
        })
      } catch (error) {
        allErrors.push(`SIFT shaders test error: ${error.message}`)
        allTestResults.push({
          type: 'SIFT Shader',
          name: 'SIFT Shaders Test',
          passed: false,
          error: error.message
        })
      }

      // Run worker test with default image
      console.log('Running worker test with default image...')
      try {
        await new Promise((resolve) => {
          // Override worker message handler to collect errors but still update images
          const originalRunWorkerTest = runWorkerTest
          runWorkerTest = function (imageUrl) {
            const promise = new Promise((resolveWorker) => {
              // Display the original image
              document.getElementById('originalImage').src = imageUrl

              const worker = new Worker('worker_webgpu.js', {type: 'module'})

              worker.onmessage = (e) => handleWorkerMessage(e, {
                errorCollector: allErrors,
                resolvePromise: resolveWorker,
                onProcessed: (result, features) => {
                  // Add successful test result
                  allTestResults.push({
                    type: 'Worker',
                    name: 'Default Image Test',
                    passed: true,
                    message: `Processed successfully. Found ${features ? features.length : 0} features.`
                  })
                },
                onError: (message) => {
                  // Add failed test result
                  allTestResults.push({
                    type: 'Worker',
                    name: 'Default Image Test',
                    passed: false,
                    error: message
                  })
                }
              })

              worker.onerror = (error) => handleWorkerError(error, {
                errorCollector: allErrors,
                resolvePromise: resolveWorker
              })

              worker.postMessage({imageUrl})
            })

            return promise
          }

          runWorkerTest('3916587d9b.png').then(() => {
            // Restore original runWorkerTest function
            runWorkerTest = originalRunWorkerTest
            resolve()
          })
        })
      } catch (error) {
        allErrors.push(`Worker test error: ${error.message}`)
        allTestResults.push({
          type: 'Worker',
          name: 'Default Image Test',
          passed: false,
          error: error.message
        })
      }

      // Run single feature test
      console.log('Running single feature test...')
      try {
        await new Promise((resolve) => {
          // Create a wrapper for the single feature test
          const runSingleFeatureTestWrapper = async () => {
            // Create the test image
            const imageUrl = createSingleFeatureTestImage()

            // Display the original image
            document.getElementById('originalImage').src = imageUrl

            // Create the worker
            const worker = new Worker('worker_webgpu.js', {type: 'module'})

            // Set up message handler with feature verification callback
            worker.onmessage = (e) => handleWorkerMessage(e, {
              errorCollector: allErrors,
              resolvePromise: resolve,
              onProcessed: (result, features) => {
                // Accept either 0 or 1 features as valid
                if (features.length === 0) {
                  console.log('PASS: No features detected - this is acceptable for this test')
                  // Add successful test result
                  allTestResults.push({
                    type: 'Single Feature',
                    name: 'Feature Detection',
                    passed: true,
                    message: 'No features detected - this is acceptable for this test'
                  })
                } else if (features.length === 1) {
                  console.log('PASS: Exactly one feature detected')

                  // Verify the feature is at the expected location
                  const feature = features[0]
                  console.log(`Feature location: (${feature.x}, ${feature.y})`)

                  // The feature should be at or near (50, 50)
                  // Allow some tolerance due to the SIFT algorithm
                  if (feature.x > 40 && feature.x < 60 && feature.y > 40 && feature.y < 60) {
                    console.log('PASS: Feature is at the expected location')
                    // Add successful test result
                    allTestResults.push({
                      type: 'Single Feature',
                      name: 'Feature Detection',
                      passed: true,
                      message: `Exactly one feature detected at (${feature.x.toFixed(1)}, ${feature.y.toFixed(1)})`
                    })
                  } else {
                    const errorMessage = `FAIL: Feature is not at the expected location. Found at (${feature.x}, ${feature.y})`
                    console.error(errorMessage)
                    allErrors.push(errorMessage)
                    // Add failed test result
                    allTestResults.push({
                      type: 'Single Feature',
                      name: 'Feature Location',
                      passed: false,
                      error: `Feature is not at the expected location. Found at (${feature.x.toFixed(1)}, ${feature.y.toFixed(1)})`
                    })
                  }
                } else {
                  const errorMessage = `FAIL: Expected 0 or 1 features, but found ${features.length}`
                  console.error(errorMessage)
                  allErrors.push(errorMessage)
                  // Add failed test result
                  allTestResults.push({
                    type: 'Single Feature',
                    name: 'Feature Count',
                    passed: false,
                    error: `Expected 0 or 1 features, but found ${features.length}`
                  })
                }
              },
              onError: (message) => {
                // Add failed test result
                allTestResults.push({
                  type: 'Single Feature',
                  name: 'Worker Processing',
                  passed: false,
                  error: message
                })
              }
            })

            // Set up error handler
            worker.onerror = (error) => handleWorkerError(error, {
              errorCollector: allErrors,
              resolvePromise: resolve
            })

            // Send the image URL to the worker
            worker.postMessage({imageUrl})
            console.log('Message sent to worker')
          }

          runSingleFeatureTestWrapper()
        })
      } catch (error) {
        const errorMessage = `Single feature test error: ${error.message}`
        console.error(errorMessage)
        allErrors.push(errorMessage)
        // Add failed test result
        allTestResults.push({
          type: 'Single Feature',
          name: 'Test Execution',
          passed: false,
          error: error.message
        })
      }

      // Run shader unit tests
      console.log('Running shader unit tests...')
      try {
        // Import the runShaderTests function
        const {runShaderTests} = await import('./shader_tests.js')
        const results = await runShaderTests()
        console.log(`Shader tests completed: ${results.passed} passed, ${results.failed} failed`)

        // Add all shader test results to the test results list
        for (const test of results.tests) {
          allTestResults.push({
            type: 'Shader Unit Test',
            name: test.name,
            passed: test.passed,
            message: test.passed ? test.message : '',
            error: test.passed ? '' : (test.error || test.message),
            hash: test.hash || `#shader-${test.name}` // Use the hash from the test or create it
          })

          // Also add any failures to the error list
          if (!test.passed) {
            const errorMessage = `Shader test failed: ${test.name} - ${test.error || test.message}`
            console.error(errorMessage)
            allErrors.push(errorMessage)
          }
        }
      } catch (error) {
        const errorMessage = `Shader tests error: ${error.message}`
        console.error(errorMessage)
        allErrors.push(errorMessage)
        allTestResults.push({
          type: 'Shader Unit Test',
          name: 'Shader Tests Execution',
          passed: false,
          error: error.message,
          hash: '#shader-Shader Tests Execution'
        })
      }

      // Display the report
      console.log('All tests completed. Generating report...')

      // Display the test results table
      const testResultsSection = displayTestResultsTable(allTestResults)

      // Display the error report if there are errors
      if (allErrors.length === 0) {
        reportElement.innerHTML = '<h2>AI Debug Report</h2><p>No errors found! All tests passed successfully.</p>'
      } else {
        reportElement.innerHTML = `
                        <h2>AI Debug Report</h2>
                        <p>Found ${allErrors.length} errors:</p>
                        <ul>
                            ${allErrors.map(error => `<li>${error}</li>`).join('')}
                        </ul>
                    `
      }

      reportElement.style.display = 'block'

      // Add a close button
      const closeButton = document.createElement('button')
      closeButton.textContent = 'Close Report'
      closeButton.onclick = () => {
        reportElement.style.display = 'none'
      }
      reportElement.appendChild(closeButton)

      // Create a hidden element with the JSON data for the AI
      const aiDataElement = document.createElement('div')
      aiDataElement.id = 'ai-error-report-data'
      aiDataElement.style.display = 'none'
      aiDataElement.textContent = JSON.stringify({
        timestamp: new Date().toISOString(),
        errors: allErrors,
        userAgent: navigator.userAgent,
        url: window.location.href
      })

      // Remove any existing AI data elements
      const existingElement = document.getElementById('ai-error-report-data')
      if (existingElement) {
        document.body.removeChild(existingElement)
      }

      document.body.appendChild(aiDataElement)

      // Log the report for the AI
      console.log('AI_ERROR_REPORT:', JSON.stringify({
        errors: allErrors
      }))

      // Collect and send test results immediately after tests complete
      collectTestResults()

    } catch (error) {
      console.error('Error running tests:', error)
      reportElement.innerHTML = `
                    <h2>AI Debug Report</h2>
                    <p>Error running tests: ${error.message}</p>
                `
      reportElement.style.display = 'block'
    }

    // Restore original sendErrorToAI
    sendErrorToAI = originalSendErrorToAI
  }

  // Check if WebGPU is supported
  if (navigator.gpu) {
    console.log('WebGPU is supported in this browser')

    // Add buttons to test WebGPU directly in the main thread
    const testWebGPUButton = document.createElement('button')
    testWebGPUButton.textContent = 'Test WebGPU in Main Thread'
    testWebGPUButton.style.marginLeft = '10px'
    testWebGPUButton.onclick = testWebGPUDirectly
    document.querySelector('div').appendChild(testWebGPUButton)

    // Add button to test SIFT shaders directly
    const testSIFTShadersButton = document.createElement('button')
    testSIFTShadersButton.textContent = 'Test SIFT Shaders'
    testSIFTShadersButton.style.marginLeft = '10px'
    testSIFTShadersButton.onclick = testSIFTShaders
    document.querySelector('div').appendChild(testSIFTShadersButton)

    // Add button to run all tests and collect all errors
    const runAllTestsButton = document.createElement('button')
    runAllTestsButton.textContent = 'Run All Tests (AI Debug)'
    runAllTestsButton.style.marginLeft = '10px'
    runAllTestsButton.style.backgroundColor = '#ffdddd'
    runAllTestsButton.onclick = runAllTests
    document.querySelector('div').appendChild(runAllTestsButton)
  } else {
    console.error('WebGPU is NOT supported in this browser')
  }

  // Function to test the SIFT shaders directly
  async function testSIFTShaders () {
    console.log('Testing SIFT shaders directly...')
    try {
      // Import the shader code
      const {
        gaussianBlurShader,
        dogShader,
        keypointDetectionShader,
        visualizeKeypointsShader
      } = await import('./sift-shaders.js')

      // Request adapter and device
      const adapter = await navigator.gpu.requestAdapter()
      if (!adapter) {
        throw new Error('No appropriate GPU adapter found')
      }
      console.log('WebGPU adapter obtained:', adapter.name)

      // Request device
      const device = await adapter.requestDevice({
        label: 'SIFT Shader Test Device'
      })
      console.log('WebGPU device obtained')

      // Set up error handling for the device
      device.addEventListener('uncapturederror', (event) => {
        const errorMessage = `WebGPU uncaptured error: ${event.error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      })

      // Test each shader
      console.log('Testing Gaussian Blur Shader...')
      try {
        const gaussianModule = device.createShaderModule({
          label: 'Gaussian Blur Shader Test',
          code: gaussianBlurShader
        })
        console.log('Gaussian Blur Shader compiled successfully')
      } catch (error) {
        const errorMessage = `Gaussian Blur Shader error: ${error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      }

      console.log('Testing DoG Shader...')
      try {
        const dogModule = device.createShaderModule({
          label: 'DoG Shader Test',
          code: dogShader
        })
        console.log('DoG Shader compiled successfully')
      } catch (error) {
        const errorMessage = `DoG Shader error: ${error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      }

      console.log('Testing Keypoint Detection Shader...')
      try {
        const keypointModule = device.createShaderModule({
          label: 'Keypoint Detection Shader Test',
          code: keypointDetectionShader
        })
        console.log('Keypoint Detection Shader compiled successfully')
      } catch (error) {
        const errorMessage = `Keypoint Detection Shader error: ${error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      }

      console.log('Testing Visualize Keypoints Shader...')
      try {
        const visualizeModule = device.createShaderModule({
          label: 'Visualize Keypoints Shader Test',
          code: visualizeKeypointsShader
        })
        console.log('Visualize Keypoints Shader compiled successfully')
      } catch (error) {
        const errorMessage = `Visualize Keypoints Shader error: ${error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      }

      console.log('All SIFT shaders tested')
    } catch (error) {
      const errorMessage = `SIFT shader test error: ${error.message}`
      console.error(errorMessage)
      sendErrorToAI(errorMessage)
    }
  }

  // Function to test WebGPU directly in the main thread
  async function testWebGPUDirectly () {
    console.log('Testing WebGPU directly in main thread...')
    try {
      // Request adapter
      const adapter = await navigator.gpu.requestAdapter()
      if (!adapter) {
        throw new Error('No appropriate GPU adapter found')
      }
      console.log('WebGPU adapter obtained:', adapter.name)

      // Request device
      const device = await adapter.requestDevice({
        label: 'Test WebGPU Device'
      })
      console.log('WebGPU device obtained')

      // Set up error handling for the device
      device.addEventListener('uncapturederror', (event) => {
        const errorMessage = `WebGPU uncaptured error: ${event.error.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      })

      // Try to create a simple shader module to test shader compilation
      try {
        const shaderModule = device.createShaderModule({
          label: 'Test Shader',
          code: `
                            @vertex
                            fn vertexMain(@builtin(vertex_index) vertexIndex: u32) -> @builtin(position) vec4<f32> {
                                var pos = array<vec2<f32>, 3>(
                                    vec2<f32>(0.0, 0.5),
                                    vec2<f32>(-0.5, -0.5),
                                    vec2<f32>(0.5, -0.5)
                                );
                                return vec4<f32>(pos[vertexIndex], 0.0, 1.0);
                            }

                            @fragment
                            fn fragmentMain() -> @location(0) vec4<f32> {
                                return vec4<f32>(1.0, 0.0, 0.0, 1.0);
                            }
                        `
        })
        console.log('Shader module created successfully')

        // Create a simple pipeline to test the shader
        const pipeline = device.createRenderPipeline({
          label: 'Test Pipeline',
          layout: 'auto',
          vertex: {
            module: shaderModule,
            entryPoint: 'vertexMain'
          },
          fragment: {
            module: shaderModule,
            entryPoint: 'fragmentMain',
            targets: [{format: 'bgra8unorm'}]
          },
          primitive: {
            topology: 'triangle-list'
          }
        })
        console.log('Render pipeline created successfully')

        console.log('WebGPU test completed successfully')
      } catch (shaderError) {
        const errorMessage = `Shader compilation error: ${shaderError.message}`
        console.error(errorMessage)
        sendErrorToAI(errorMessage)
      }
    } catch (error) {
      const errorMessage = `WebGPU test error: ${error.message}`
      console.error(errorMessage)
      sendErrorToAI(errorMessage)
    }
  }
</script>
</body>
</html>
